{
    "collab_server" : "",
    "contents" : "#\n# Henry samuelson 11/2/17\n#\n# RSA\n#\n#' @examples\n#' RSA.Decrypt(RSA.Encrypt(2198, publicKey = publicKey), privateKey = privateKey)\n\nlibrary(numbers)\nlibrary(gmp)\nRSAkeyGen <- function(\n  p = 61,\n  q = 53) {\n  n = q*p\n  #n\n  totient <- LCM(q-1, p-1)\n\n  e <- 17 # e has to to be co prome with totient\n  e <- numeric()\n  coPrime.T <- T\n  while(coPrime.T) {\n    ran.int <- floor(runif(1, 0, totient))\n    if(coprime(totient, ran.int)){\n      coPrime.T <- F\n      e <- ran.int\n    }\n  }\n\n  #euler Metheod\n  # (d * e) %% totient = 1\n  for (x in 1:1000000){\n    if ((1+x*totient)%%e == 0 && isprime((1+x*totient)/e)==0 ){\n      d <<- (1+x*totient)/e\n      if (isprime(d) != 0){\n        return(\"D is prime, Error\")\n      }\n      break\n    }\n  }\n\n  publicKey <<- list(n, e)\n  privateKey <<- list(n, d)\n  #return(c(publicKey, privateKey))\n  #print(publicKey)\n  #print(privateKey)\n}\n\nmessage <- 1234 #Up to four digits if more the program breaks\n\nRSA.Encrypt <- function(message, publicKey) {\n  n1 <- publicKey[[1]]\n  e1 <- publicKey[[2]]\n  return(as.integer(mod.bigz(as.bigz(pow.bigz(message, e1)), n1)))\n}\nRSA.Decrypt <- function(message.Rescived, privateKey){\n  n1 <- privateKey[[1]]\n  d1 <- privateKey[[2]]\n  return(as.integer(mod.bigz(as.bigz(pow.bigz(message.Rescived, d1)), n1)))\n}\n\n\n\n\n\n",
    "created" : 1510115646528.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3463742417",
    "id" : "56056E95",
    "lastKnownWriteTime" : 1510115668,
    "last_content_update" : 1510115668405,
    "path" : "C:/Users/hsamuelson/Desktop/ciphr/R/RSA.R",
    "project_path" : "R/RSA.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}