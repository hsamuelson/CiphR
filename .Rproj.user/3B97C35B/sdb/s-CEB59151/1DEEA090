{
    "collab_server" : "",
    "contents" : "#' A ml modular framework\n#'\n#' This function allows you to express your love of cats.\n#' @name rnetf \n#' @param rnetf type stuff\n#' @keywords neuralnetwork\n#' @export\n#' @examples\n#' rnetf()\n\nif (!require(\"neuralnet\")) install.packages(\"neuralnet\")\nlibrary(neuralnet)\nrnetf <- function (\nhiddenMode = 3,\nfinal.id = 1,\nclassColumn.range = 2:4,\nDat = idenity,\ninputDat = 0,              #has to NOT have both class idenityies, in order to predict them. \nthres = 0.01 ) {\n  if(sum(Dat) == 0){\n    return(\"ERROR No Dat: Dat == 0\")\n  }\n  if(final.id == 0){\n    return(\"ERROR: Final.id == 0: No Column to train for selected\")\n  }\n  if(sum(classColumn.range) == 0){\n    return(\"ERROR: no classcolumn.range\")\n  }\n  if(sum(inputDat) == 0){\n    return(\"No input Data\")\n  }\n  #Setting up classrange\n  equationPLus <- Dat #what we will take columnnames() from to generate C~A+B\n  if(sum(classColumn.range) == 0 ){\n    #Then all columns will be considered for subclasses\n    print(\"All columns will be considered for SubClasses\")\n    \n    classColumn.range <- Dat\n    classColumn.range[,final.id] <- NULL\n    return(\"This function is not supported yet.... Please provide a value for classColumn.range\")\n    \n  } else{\n    holder <- equationPLus\n    \n    for( i in classColumn.range){\n      holder[paste(colnames(equationPLus[i]))] <- NULL\n\n    }\n    equationPLus <- holder\n    \n    classColumn.range <- Dat[,classColumn.range]\n  }\n  #Create final.id\n  equationPLus[,final.id] <- NULL\n  \n  \n  hiddenSelect <- function(hidd){ #w will be Dat\n    if(hidd == 1){\n      hiddenMode <- round(length(colnames(equationPLus)))\n      \n    } else if(hidd == 2){\n      hiddenMode <- round((round(length(colnames(equationPLus))) + 1)/(2/3))\n    } else if(hidd == 3){\n      hiddenMode <- round(sqrt(length(colnames(equationPLus))*  length(Dat[,1]) ))\n    }\n    return(hiddenMode)\n  }\n  \n  classColumn.range.names <- colnames(classColumn.range)\n  classColumn.range.values <- numeric(0)\n  for(i in 1:length(classColumn.range[1,])){\n    classColumn.range.values[i] <- length(table(classColumn.range[,i]))  \n  }\n  \n  order.Set <- rbind.data.frame((1:length(classColumn.range.names)), classColumn.range.values) #hash map for names the valules in the 1:length() will corilate to classColumn.names\n  order.Set <- order.Set[order(order.Set[2,])]\n  \n  setValuefor.Order.Set <- length(order.Set[1,]) #Needs to be counted here before it is cutdown\n  for(i in 1: setValuefor.Order.Set){ #will loop for all the subclasses\n    \n    if(length(order.Set) == 0){\n      print(\"breaking order.Set == 0\")\n      break\n    }\n    \n    \n    lowest <- order.Set[1]\n    order.Set[1] <- NULL\n    \n    col_names <- colnames(equationPLus)\n    #Train algorithum\n    model_formula <- paste(paste(classColumn.range.names[lowest[1,1]]), '~', paste(col_names, collapse = '+', sep = ''))\n    nn <- neuralnet(model_formula, Dat, threshold = thres, hidden = hiddenSelect(hiddenMode) )\n    #plot(nn) #just to visulize and test remove this for final\n    net.results <- compute(nn, equationPLus[1,]) #inputDat) #equationPLus[1,]\n    net.results <- round(net.results$net.result)\n    \n    #Alternative to -which()\n    holder <- numeric(0) \n    for(j in 1:length(Dat[,1])){\n      if(Dat[j, classColumn.range.names[lowest[1,1]]] == net.results){\n        #print(j) #print when equal\n        holder <- rbind.data.frame(holder, Dat[j,])\n      }\n    }\n    Dat <- holder\n   \n  }\n  #train for final.id\n  model_formula <- paste(paste(colnames(Dat[final.id])), '~', paste(col_names, collapse = '+', sep = ''))\n  nn <- neuralnet(model_formula, Dat, threshold = thres, hidden = hiddenSelect(hiddenMode) )\n  net.results <- compute(nn, equationPLus[1,])#inputDat) #equationPLus[1,]\n  net.results <- round(net.results$net.result)\n  #net.results \n  return(net.results)\n}\n",
    "created" : 1510116048359.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1829481258",
    "id" : "1DEEA090",
    "lastKnownWriteTime" : 1505358004,
    "last_content_update" : 1505358004,
    "path" : "~/GitHub/rnetf/R/RNetf-LibCombinded02.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}