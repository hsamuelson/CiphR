{
    "collab_server" : "",
    "contents" : "#\n# Henry Samuelson 10/18/17\n#\n# Tiny Encryption Algorithm\n#\n#' @examples\n#' results <- TinyEncrypt(v0 = vq, v1 = vw)\n#'v0.n <- results[1:32]\n#'v1.n <- results[33:64]\n#'TinyDecrypt(v0.n, v1.n)\n\nlibrary(compositions)\nlibrary(gmp)\nlibrary(magrittr)\n\n\n\n#takes string\nBINARY <- function(xx) {  #NEEDS TO RETURN exactly 32 regardless, should remove from front\n  numberIN <- as.double(strsplit(xx, \"\")[[1]])\n  if(length(numberIN) > 32){\n    while(length(numberIN) > 32){\n      numberIN<- numberIN[-1]\n    }\n  }\n  output <- rep(0,(32 - length(numberIN)))\n  output <- c(output, numberIN)#output[(length(output) - length(numberIN)):length(output)]\n\n  return(output)\n}\n\nBITTONUM <- function(xx) { #FIX ME !?!?!?!??!? WHY DOES 0^0 = 1!?!?!??!\n  #for(i in 1:length(xx)){\n  #  if(xx[i] == 1) { xx[i] <- 2}\n  #}\n  xx <- xx * 2\n  #print((length(xx) - 1):0)\n  #if(xx[length(xx)] == 2){ xx[length(xx)] <- 1}\n  suber <- 0\n  if(xx[length(xx)] == 0){suber <- 1}\n  return(sum(xx^((length(xx) - 1):0)) - suber)\n}\n\nBITL <- function(xx, shiftAmount) {\n  xx[(length(xx) + 1): (length(xx) + shiftAmount)] <- 0\n  output <- xx[-(1:shiftAmount)]\n  return(output)\n}\n\nBITR <- function(xx, shiftAmount){\n  xx <- xx[-((length(xx) - shiftAmount + 1):length(xx))]\n  placment <- rep(0,shiftAmount)\n  #return(output)\n  return(c(placment, xx))\n}\n\n#xx has to be the larger integer\nBITXOR <- function(xx, yy){\n  output <- numeric()\n\n  #correct yy (add zeros to the front)\n  yy <- c((rep(0,length(xx) - length(yy))), yy)\n  for(i in 1:length(xx)){\n    if(xx[i] != yy[i]){\n      output[i] <- 1\n    } else {\n      output[i] <- 0\n    }\n\n  }\n  return(output)\n}\n\n\n#NOt finished\nNOBINARY <- function(xx){\n  bitstring <- numeric()\n  counter <- 1\n  number <- as.bigz(paste0(asd, collapse = \"\"))\n  while(number > 0){\n    quotient <- round(div.bigz(number,2))\n    bitz <- mod.bigz(number, 2)\n    bitstring[counter] <- as.double(paste((mod.bigz(bitz, 2))))\n    number <- quotient\n    counter = counter + 1\n    print(number)\n  }\n}\n\nBITADD <- function(xx, yy) {\n  #xx = dataframe\n  #yy <- is number to muiltiply\n  return((BITTONUM(xx) + yy))\n\n}\n#Demo inputs\nvq <- BINARY(\"10101010101010101010101010101010\")\nvw <- BINARY(\"11011011011011011011011011011011\")\n\nTinyEncrypt <- function(v0, v1){\n  sum <- 0\n  delta <- 0x9e3779b9\n\n  for(i in 1:32){\n    sum = sum + delta\n    v0 <- BINARY(binary(BITTONUM(v0) + BITTONUM(BITXOR(BITXOR(BITL(v1, 4), (BINARY(binary(BITADD(v1, sum))))), BITR(v1, 5)))))\n    v1 <- BINARY(binary(BITTONUM(v1) + BITTONUM(BITXOR(BITXOR(BITL(v0, 4), (BINARY(binary(BITADD(v0, sum))))), BITR(v0, 5)))))\n  }\n  return(c(v0, v1))\n}\n\nTinyDecrypt <- function(v0, v1){\n  sum <- 0xC6EF3720\n  delta <- 0x9e3779b9\n\n  for(i in 1:32){\n    v1 <- BINARY(binary(BITTONUM(v1) - BITTONUM(BITXOR(BITXOR(BITL(v0, 4), (BINARY(binary(BITADD(v0, sum))))), BITR(v0, 5)))))\n    v0 <- BINARY(binary(BITTONUM(v0) - BITTONUM(BITXOR(BITXOR(BITL(v1, 4), (BINARY(binary(BITADD(v1, sum))))), BITR(v1, 5)))))\n    sum = sum - delta\n  }\n  return(c(v0, v1))\n}\n\n\n\n\n#Code Graveyard\n\n#0x9e3779b9\n# for(i in 1:32){\n#   sum = sum + delta\n#   v0 <- v0 + (bitwXor(bitwXor(bitwShiftL(v1, 4), (v1 + sum)), (bitwShiftR(v1, 5)) ))\n#   v1 <- v1 + (bitwXor(bitwXor(bitwShiftL(v0, 4), (v0 + sum)), (bitwShiftR(v0, 5)) ))\n#   print(v0)\n#   print(v1)\n# }\n# # k0 <- 0\n#\n# v.0 <- \"10101010101010101010101010101010\"\n# v.0 <- \"10101010101010101010101010101010000\"\n#\n# v_1 <- as.bigz(\"11011011011011011011011011011011\")\n#\n# v0.n <- 2863311530\n# v1.n <- 3681400539\n#\n#\n# v0 <- 1234\n# v1 <- 4321\n#\n#\n# #Encrypt\n# #TinyEncrypt <- function(v0, v1, k){\n# sum <- 0\n# delta <- 1 #0x9e3779b9\n#   for(i in 1:32){\n#     sum = sum + delta\n#     v0 <- v0 + (bitwXor(bitwXor(bitwShiftL(v1, 4), (v1 + sum)), (bitwShiftR(v1, 5)) ))\n#     v1 <- v1 + (bitwXor(bitwXor(bitwShiftL(v0, 4), (v0 + sum)), (bitwShiftR(v0, 5)) ))\n#     print(v0)\n#     print(v1)\n#   }\n#   #return(cbind(v0, v1))\n# #}\n#\n# #x <- c(1,0,1)\n# for(i in 1:length(x)){\n#   if(x[i] == 1) { x[i] <- 2}\n# }\n# sum(x^((length(x) -1):0))\n",
    "created" : 1510115689835.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "6401185",
    "id" : "1154E5EB",
    "lastKnownWriteTime" : 1510115800,
    "last_content_update" : 1510115800429,
    "path" : "C:/Users/hsamuelson/Desktop/ciphr/R/teacipher.R",
    "project_path" : "R/teacipher.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}